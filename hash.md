# Hash Function

## SHA-256

### **什麼是 SHA-256？**  
SHA-256（安全雜湊算法 256 位）是一種加密雜湊函數，它接收輸入並產生固定長度的 256 位（32 字節）雜湊值。它是 **SHA-2** 家族中的一員，由 **美國國家安全局（NSA）** 開發，並由 **美國國家標準與技術研究所（NIST）** 發佈。

#### **SHA-256 的主要特性**  
1. **固定長度輸出：** 無論輸入大小如何，SHA-256 始終會產生 **256 位（64 字符十六進制）** 的雜湊。  
2. **確定性：** 相同的輸入總是會產生相同的輸出。  
3. **快速計算：** 計算任何給定輸入的雜湊非常高效。  
4. **抗逆向性：** 給定一個雜湊值，計算上幾乎不可能找到原始輸入。  
5. **抗碰撞性：** 很難找到兩個不同的輸入產生相同的雜湊。  
6. **雪崩效應：** 輸入中的小變化會導致完全不同的雜湊。

---

### **SHA-256 如何在比特幣中應用？**  
比特幣使用 SHA-256 進行多個用途，主要是 **工作量證明（挖礦）** 和 **地址生成**。

#### **1. 工作量證明（挖礦）**  
比特幣挖礦依賴於 SHA-256 來驗證交易並保護網絡。其工作方式如下：  
- 礦工必須通過改變一個稱為 **隨機數（nonce）** 的數字來找到一個 **有效的雜湊**（滿足所需的難度）。  
- 挖礦過程涉及對 **區塊頭** 進行 **雙重 SHA-256** 雜湊（即 **SHA-256(SHA-256(區塊頭))**）。  
- 如果結果的雜湊值低於給定的 **目標值**，則該區塊會被網絡接受。

🔹 **挖礦中使用的區塊頭組件：**  
   - 前區塊的雜湊  
   - Merkle 樹根（所有交易的雜湊）  
   - 時間戳  
   - 隨機數（礦工改變此數字以尋找有效雜湊）  
   - 難度目標  

#### **2. 比特幣地址生成**  
SHA-256 也用於創建比特幣地址：  
1. 生成 **私鑰**。  
2. 使用 **橢圓曲線數字簽名算法（ECDSA）** 將私鑰轉換為 **公鑰**。  
3. 對公鑰進行雜湊處理：  
   - **SHA-256**（生成第一次雜湊）  
   - **RIPEMD-160**（縮短雜湊）  
4. 使用 **雙重 SHA-256** 添加檢查碼。  
5. 將結果轉換為 **Base58Check 編碼**，生成最終的比特幣地址。

---

### **範例：比特幣中的 SHA-256 雜湊**  
如果您對單詞 `"Bitcoin"` 進行 SHA-256 雜湊：

```
SHA-256("Bitcoin") =  6b600a8c9a00850ed1e795e4c45aebd5cb3d10cbcad1d344f291218da5bda115
```

稍微改變輸入會導致雜湊發生巨大變化：

```
SHA-256("bitcoin") =  6b9b4d6c01f76aa7a8108cb45efb01c32022635c90260b3b30dc5ef190d4362b
```

---

### **為什麼 SHA-256 對比特幣如此重要？**  
- **安全性：** SHA-256 的加密強度使得逆向或篡改交易變得不可能。  
- **去中心化：** 挖礦競爭確保沒有單一實體能控制整個網絡。  
- **防篡改：** 區塊鏈中任何微小的修改都會改變雜湊，使比特幣變得不可變。

---

### **比特幣的雜湊函數輸入是什麼？**  
比特幣礦工會對**區塊頭**進行雜湊，該區塊頭包含：  

| 欄位                 | 大小   | 描述               |
|----------------------|--------|--------------------|
| **版本**             | 4 字節 | 區塊格式版本       |
| **前區塊雜湊**       | 32 字節 | 前一區塊的雜湊     |
| **Merkle 樹根**      | 32 字節 | 所有交易的雜湊     |
| **時間戳**           | 4 字節 | 當前時間（Unix 時間戳）|
| **難度目標**         | 4 字節 | 挖礦的目標值       |
| **隨機數 (Nonce)**   | 4 字節 | 用於尋找有效雜湊的隨機數 |

🔹 礦工會不斷改變 **隨機數** 直到區塊頭的 SHA-256 雜湊 **低於目標難度**。  

---

## SHA-256 的過程

### **SHA-256 如何處理數據？**  
SHA-256 通過 **一系列數學變換** 處理數據，產生 **固定 256 位（32 字節）雜湊值**。以下是 SHA-256 雜湊過程的詳細步驟。

---

## **SHA-256 的步驟流程**
### **1. 將輸入轉換為二進制**
- 輸入（訊息）首先會轉換為 **二進制表示**。
- 例如，ASCII 文字 **"hello"** 轉換為二進制為：

  ```
  01101000 01100101 01101100 01101100 01101111
  ```

---

### **2. 填充訊息**
SHA-256 要求輸入長度必須是 **512 位（64 字節）的倍數**。如果輸入較短，則會進行 **填充**：
- 添加 **單個 `1` 位**。
- 隨後添加一系列 **`0` 位**。
- 最後 **64 位** 存儲原始訊息的長度。

#### **示例：**
- 假設原始訊息是 **"hello"**（40 位）。
- 填充後長度會變為 **512 位**。

---

### **3. 將訊息分成 512 位塊**
- 填充後的訊息會被 **分成 512 位塊**。
- 如果訊息超過 512 位，則會被分為多個塊，逐一處理。

---

### **4. 初始化雜湊值（8 個常數）**
SHA-256 以 **八個 32 位的固定雜湊值** 開始（十六進制表示）：

```
h0 = 6a09e667
h1 = bb67ae85
h2 = 3c6ef372
h3 = a54ff53a
h4 = 510e527f
h5 = 9b05688c
h6 = 1f83d9ab
h7 = 5be0cd19
```

---

### **5. 創建 64 個訊息計劃詞**
- 512 位的區塊會被擴展成 **64 個詞**（每個 32 位）。
- 前 **16 個詞** 直接來自訊息。
- 其餘 **48 個詞** 會通過位操作和前面詞的計算來生成。

---

### **6. 進行 64 輪壓縮運算**
SHA-256 會執行 **64 輪運算**，使用位操作、模算術和邏輯函數。

每一輪運算涉及：
- 一組 64 個常數值（`K[0]` 到 `K[63]`），這些常數來自於前 64 個質數的立方根。
- **位操作**，包括旋轉、異或（XOR）、與（AND）和模加法。

每一輪都會更新八個雜湊值（`h0` 到 `h7`）。

---

### **7. 最終雜湊值**
- 經過 64 輪運算後，八個雜湊值（`h0` 到 `h7`）會與之前的雜湊值相加。
- 最終的雜湊值是將 `h0` 到 `h7` 進行 **串接** 得到的（256 位或 64 個十六進制字符）。

例如：

```
SHA-256("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
```

---

## **範例：Python 中的 SHA-256**
以下是如何使用 Python 內建的 `hashlib` 來雜湊一個值：

```python
import hashlib

message = "hello".encode()  # 將訊息轉為字節
hash_object = hashlib.sha256(message)  # 計算 SHA-256 雜湊
hash_hex = hash_object.hexdigest()  # 轉換為十六進制

print(hash_hex)
```

### **輸出：**
```
2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
```

---

## **為什麼 SHA-256 是安全的？**
1. **單向函數** → 不能逆向雜湊來獲得原始訊息。
2. **雪崩效應** → 輸入中任何微小的變化都會大幅改變雜湊。
3. **抗碰撞性** → 很難找到兩個不同的輸入，產生相同的雜湊。

--- 

### 簡單的 Implementation

```python
# 初始化工作變量
a, b, c, d, e, f, g, h = H

# 主循環
for i in range(64):
    Σ1 = (e >> 6) ^ (e >> 11) ^ (e >> 25)
    Ch = (e & f) ^ (~e & g)
    temp1 = h + Σ1 + Ch + K[i] + W[i]
    Σ0 = (a >> 2) ^ (a >> 13) ^ (a >> 22)
    Maj = (a & b) ^ (a & c) ^ (b & c)
    temp2 = Σ0 + Maj

    h = g
    g = f
    f = e
    e = d + temp1
    d = c
    c = b
    b = a
    a = temp1 + temp2

# 更新哈希值
H[0] += a
H[1] += b
H[2] += c
H[3] += d
H[4] += e
H[5] += f
H[6] += g
H[7] += h
```


